# Scalars

" Date "
scalar Date
" Date with no time of day "
scalar TimelessDate
" IBAN "
scalar IBAN
" Percentage"
scalar Percentage
" Rate "
scalar Rate
" URL "
scalar URL
" File "
scalar File

# Common Types

" a date range "
type DateRange {
  start: TimelessDate!
  end: TimelessDate!
}

" represent a link to an external file "
interface Linkable {
  file: URL
}

" represent a generic document with identifier and a URL "
interface Document implements Linkable {
  id: ID!
  " previewable image "
  image: URL
  " link to original file gmail, pdf "
  file: URL
  charge: Charge
  " the specific type of the document"
  # eslint-disable-next-line @graphql-eslint/no-typename-prefix
  documentType: DocumentType
  creditor: String
  debtor: String
  isReviewed: Boolean
}

" Represent financial amount "
type FinancialAmount {
  " the raw amount, for example: 19.99 "
  raw: Float!
  " formatted value with the currency symbol, like: 10$ "
  formatted: String!
  " currency of the amount "
  currency: Currency!
}

" All possible currencies "
enum Currency {
  USD
  ILS
  GBP
  EUR
}

" All possible document types "
enum DocumentType {
  INVOICE
  RECEIPT
  INVOICE_RECEIPT
  PROFORMA
  UNPROCESSED
}

" The other side of a transaction "
interface Counterparty {
  name: String!
}

" The direction of the transaction "
enum TransactionDirection {
  DEBIT
  CREDIT
}

# Root types

" query root "
type Query {
  financialEntity(id: ID!): FinancialEntity!
  documents: [Document!]!
  chargeById(id: ID!): Charge!
  allCharges(filters: ChargeFilter, page: Int = 1, limit: Int = 999999): PaginatedCharges!
  " TODO: This is temporary, should be replaced after auth and financial entities hierarchy is implemented "
  allFinancialEntities: [FinancialEntity!]!
  allSortCodes: [SortCode!]!
  businessTransactionsSumFromLedgerRecords(
    filters: BusinessTransactionsFilter
  ): BusinessTransactionsSumFromLedgerRecordsResult!
  businessTransactionsFromLedgerRecords(
    filters: BusinessTransactionsFilter
  ): BusinessTransactionsFromLedgerRecordsResult!
  businessNamesFromLedgerRecords: [String!]!
}

" mutation root "
type Mutation {
  updateCharge(chargeId: ID!, fields: UpdateChargeInput!): UpdateChargeResult!
  updateTransaction(transactionId: ID!, fields: UpdateTransactionInput!): UpdateTransactionResult!
  updateLedgerRecord(
    ledgerRecordId: ID!
    fields: UpdateLedgerRecordInput!
  ): UpdateLedgerRecordResult!
  insertLedgerRecord(chargeId: ID!, record: InsertLedgerRecordInput!): InsertLedgerRecordResult!
  " TEMPORARY: to enable direct full update of the record "
  updateDbLedgerRecord(
    ledgerRecordId: ID!
    fields: UpdateDbLedgerRecordInput!
  ): UpdateLedgerRecordResult!
  " TEMPORARY: to enable direct full update of the record "
  insertDbLedgerRecord(chargeId: ID!, record: InsertDbLedgerRecordInput!): InsertLedgerRecordResult!
  toggleLedgerRecordAccountantApproval(ledgerRecordId: ID!, approved: Boolean!): Boolean!
  toggleChargeAccountantApproval(chargeId: ID!, approved: Boolean!): Boolean!
  generateLedgerRecords(chargeId: ID!): GenerateLedgerRecordsResult!
  deleteLedgerRecord(ledgerRecordId: ID!): Boolean!
  insertDocument(record: InsertDocumentInput!): InsertDocumentResult!
  updateDocument(documentId: ID!, fields: UpdateDocumentFieldsInput!): UpdateDocumentResult!
  deleteDocument(documentId: ID!): Boolean!
  fetchEmailDocument(url: URL!): FetchEmailDocumentResult!
  uploadDocument(file: File!, chargeId: ID): UploadDocumentResult!
}

" input variables for businessTransactions "
input BusinessTransactionsFilter {
  businessNames: [String!]
  financialEntityIds: [ID!]
  fromDate: TimelessDate
  toDate: TimelessDate
}

" result type for businessTransactionsSumFromLedgerRecords "
union BusinessTransactionsSumFromLedgerRecordsResult =
    BusinessTransactionsSumFromLedgerRecordsSuccessfulResult
  | CommonError

" result type for businessTransactionsSumFromLedgerRecords" # eslint-disable-next-line @graphql-eslint/strict-id-in-types -- no current solution for this
type BusinessTransactionsSumFromLedgerRecordsSuccessfulResult {
  businessTransactionsSum: [BusinessTransactionSum!]!
}

" single business transaction summery " # eslint-disable-next-line @graphql-eslint/strict-id-in-types -- no current solution for this
type BusinessTransactionSum {
  businessName: String!
  credit: FinancialAmount!
  debit: FinancialAmount!
  total: FinancialAmount!
  eurSum: ForeignCurrencySum
  gbpSum: ForeignCurrencySum
  usdSum: ForeignCurrencySum
  sortCode: SortCode
}

" Hashavshevet sort code "
type SortCode {
  id: Int!
  name: String
  accounts: [HashavshevetAccount!]!
}

" Hashavshevet account "
type HashavshevetAccount {
  id: ID!
  key: String!
  sortCode: SortCode!
  name: String
}

" summary of foreign currency business transactions " # eslint-disable-next-line @graphql-eslint/strict-id-in-types -- no current solution for this
type ForeignCurrencySum {
  credit: FinancialAmount!
  debit: FinancialAmount!
  total: FinancialAmount!
}

" result type for businessTransactionsFromLedgerRecords "
union BusinessTransactionsFromLedgerRecordsResult =
    BusinessTransactionsFromLedgerRecordsSuccessfulResult
  | CommonError

" result type for businessTransactionsFromLedgerRecords" # eslint-disable-next-line @graphql-eslint/strict-id-in-types -- no current solution for this
type BusinessTransactionsFromLedgerRecordsSuccessfulResult {
  businessTransactions: [BusinessTransaction!]!
}

" single business transaction info " # eslint-disable-next-line @graphql-eslint/strict-id-in-types -- no current solution for this
type BusinessTransaction {
  amount: FinancialAmount!
  businessName: String!
  eurAmount: FinancialAmount
  gbpAmount: FinancialAmount
  usdAmount: FinancialAmount
  invoiceDate: TimelessDate!
  reference1: String
  reference2: String
  details: String
  counterAccount: String
}

" input variables for updateDocument "
input UpdateDocumentFieldsInput {
  vat: FinancialAmountInput
  serialNumber: String
  date: TimelessDate
  amount: FinancialAmountInput
  documentType: DocumentType
  image: URL
  file: URL
  chargeId: ID
  creditor: String
  debtor: String
}

" input variables for updateCharge "
input UpdateChargeInput {
  # createdAt: Date!
  # additionalDocument: [Linkable!]!
  # ledgerRecords: [LedgerRecord!]!
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # transactions: [Transaction!]!
  counterparty: CounterpartyInput
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # description: String
  tags: [TagInput!]
  beneficiaries: [BeneficiaryInput!]
  vat: Float
  withholdingTax: Float
  totalAmount: FinancialAmountInput
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # invoice: Invoice
  accountantApproval: AccountantApprovalInput
  isProperty: Boolean
  # businessTrip: BusinessTrip
}

" input variables for updateLedgerRecord "
input UpdateLedgerRecordInput {
  creditAccount: CounterpartyInput
  debitAccount: CounterpartyInput
  originalAmount: FinancialAmountInput
  date: TimelessDate
  " Temporary. should be removed "
  valueDate: TimelessDate
  " Temporary. should be removed "
  date3: TimelessDate
  description: String
  accountantApproval: AccountantApprovalInput
  " in shekels at the moment"
  localCurrencyAmount: FinancialAmountInput
  hashavshevetId: Int
}

" input variables for insertLedgerRecord "
input InsertLedgerRecordInput {
  creditAccount: CounterpartyInput
  debitAccount: CounterpartyInput
  originalAmount: FinancialAmountInput
  date: TimelessDate #invoiceDate
  " Temporary. should be removed "
  valueDate: TimelessDate
  " Temporary. should be removed "
  date3: TimelessDate
  description: String
  accountantApproval: AccountantApprovalInput
  " in shekels at the moment"
  localCurrencyAmount: FinancialAmountInput
  hashavshevetId: Int
}

" TEMPORARY: input variables for updateDbLedgerRecord "
input UpdateDbLedgerRecordInput {
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_account_1: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_account_2: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_amount_2: Float
  currency: Currency
  date3: TimelessDate
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_account_1: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_account_2: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_amount_2: Float
  details: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_credit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_credit_amount_2: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_debit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_debit_amount_2: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  hashavshevet_id: Int
  # eslint-disable-next-line @graphql-eslint/naming-convention
  invoice_date: TimelessDate
  # eslint-disable-next-line @graphql-eslint/naming-convention
  movement_type: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  reference_1: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  reference_2: String
  reviewed: Boolean
  # eslint-disable-next-line @graphql-eslint/naming-convention
  value_date: TimelessDate
}

" TEMPORARY: input variables for insertDbLedgerRecord "
input InsertDbLedgerRecordInput {
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_account_1: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_account_2: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_amount_2: Float
  currency: Currency
  date3: TimelessDate!
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_account_1: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_account_2: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_amount_2: Float
  details: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_credit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_credit_amount_2: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_debit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_debit_amount_2: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  hashavshevet_id: Int
  # eslint-disable-next-line @graphql-eslint/naming-convention
  invoice_date: TimelessDate!
  # eslint-disable-next-line @graphql-eslint/naming-convention
  movement_type: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  reference_1: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  reference_2: String
  reviewed: Boolean
  # eslint-disable-next-line @graphql-eslint/naming-convention
  value_date: TimelessDate!
}

" input variables for insertDocument "
input InsertDocumentInput {
  image: URL
  file: URL
  vat: FinancialAmountInput
  documentType: DocumentType
  serialNumber: String
  date: TimelessDate
  amount: FinancialAmountInput
  chargeId: ID
  creditor: String
  debtor: String
}

" input variables for updateTransaction "
input UpdateTransactionInput {
  referenceNumber: String
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # createdAt: Date!
  effectiveDate: TimelessDate
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # direction: TransactionDirection
  amount: FinancialAmountInput
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # description: String // NOTE: which field should be updated? and should we update fields originated at bank/card info?
  userNote: String
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # account: FinancialAccount
  balance: FinancialAmountInput
  accountantApproval: AccountantApprovalInput
  hashavshevetId: Int
}

" input variables for updateCharge.Counterparty"
input CounterpartyInput {
  name: String!
}

" input variables for Tag"
input TagInput {
  name: String!
}

" input variables for beneficiary"
input BeneficiaryInput {
  counterparty: CounterpartyInput!
  percentage: Percentage!
}

" input variables for updateCharge.AccountantApproval"
input AccountantApprovalInput {
  approved: Boolean!
  remark: String
}

" input variables for updateCharge.FinancialAmount"
input FinancialAmountInput {
  raw: Float!
  currency: Currency!
}

" basic structure of error "
interface Error {
  message: String!
}

" common type of errors"
type CommonError implements Error {
  message: String!
}

" result type for updateCharge "
union UpdateDocumentResult = UpdateDocumentSuccessfulResult | CommonError

" result type for updateDocument" # eslint-disable-next-line @graphql-eslint/strict-id-in-types -- no current solution for this
type UpdateDocumentSuccessfulResult {
  document: Document
}

" result type for updateCharge "
union UpdateChargeResult = Charge | CommonError

" result type for updateLedgerRecord "
union UpdateLedgerRecordResult = LedgerRecord | CommonError

" result type for insertLedgerRecord "
union InsertLedgerRecordResult = Charge | CommonError

" result type for insertDocument "
union InsertDocumentResult = InsertDocumentSuccessfulResult | CommonError

" result type for insertDocument" # eslint-disable-next-line @graphql-eslint/strict-id-in-types -- no current solution for this
type InsertDocumentSuccessfulResult {
  document: Document
}

" result type for fetchEmailDocument "
union FetchEmailDocumentResult = FetchEmailDocumentSuccessfulResult | CommonError

" result type for fetchEmailDocument" # eslint-disable-next-line @graphql-eslint/strict-id-in-types -- no current solution for this
type FetchEmailDocumentSuccessfulResult {
  document: Document
}

" result type for uploadDocument "
union UploadDocumentResult = UploadDocumentSuccessfulResult | CommonError

" result type for uploadDocument" # eslint-disable-next-line @graphql-eslint/strict-id-in-types -- no current solution for this
type UploadDocumentSuccessfulResult {
  document: Document
}

" result type for updateTransaction "
union UpdateTransactionResult = CommonTransaction | CommonError # TODO: update to match more than common transaction
" result type for generateLedgerRecords "
union GenerateLedgerRecordsResult = Charge | CommonError # TODO: update to match more than common transaction
# Main Module

" Financial entity, identifier by ID, can be a company or individual "
type LtdFinancialEntity implements FinancialEntity {
  id: ID!
  govermentId: String!
  name: String!
  address: String!

  englishName: String
  email: String
  website: String
  phoneNumber: String

  accounts: [FinancialAccount!]!
  charges(filter: ChargeFilter, page: Int = 1, limit: Int = 999999): PaginatedCharges!
  linkedEntities: [FinancialEntity!]!
  documents: [Document]
}

" Financial entity, identifier by ID, represents an actual person "
type PersonalFinancialEntity implements FinancialEntity {
  id: ID!
  name: String!
  email: String!

  accounts: [FinancialAccount!]!
  charges(filter: ChargeFilter, page: Int = 1, limit: Int = 999999): PaginatedCharges!

  linkedEntities: [FinancialEntity!]!
  documents: [Document]
}

" represent a financial entity of any type that may hold financial accounts (company, business, individual) "
interface FinancialEntity {
  id: ID!
  name: String!
  accounts: [FinancialAccount!]!
  charges(filter: ChargeFilter, page: Int = 1, limit: Int = 999999): PaginatedCharges!

  linkedEntities: [FinancialEntity!]!
  documents: [Document]
}

" input variables for charge filtering "
input ChargeFilter {
  " Include only charges that doesn't have transactions linked "
  withoutTransaction: Boolean
  " Include only charges that doesn't have Ledger records linked "
  withoutLedger: Boolean
  " Include only charges that doesn't have documents linked "
  withoutDocuments: Boolean
  " Include only charges that doesn't have invoice document linked "
  withoutInvoice: Boolean
  " Include only charges occured after this date "
  fromDate: String
  " Include only charges occured before this date "
  toDate: String
  " Include only charges related to specific financial entities "
  byFinancialEntities: [ID!]
  " Include only charges related to specific financial accounts "
  byFinancialAccounts: [ID!]
  sortBy: ChargeSortBy
}

" input variables for sorting charges "
input ChargeSortBy {
  field: ChargeSortByField!
  asc: Boolean
}

" fields that can be used to sort charges "
enum ChargeSortByField {
  DATE
  AMOUNT
  ABS_AMOUNT
}

" represrent a complex type for grouped charge with ledger info, bank/card transactions and documents "
type Charge {
  id: ID!
  " when the initial charge was created from the first event we found "
  createdAt: Date!
  " additional documents attached to the charge "
  additionalDocuments: [Document!]!
  " ledger records linked to the charge "
  ledgerRecords: [LedgerRecord!]!
  " list of financial/bank transactions linked to the charge "
  transactions: [Transaction!]!
  " calculated counterparty details for the charge "
  counterparty: Counterparty
  " user description, set manually by the user "
  description: String
  " user customer tags "
  tags: [Tag!]!
  " a list of beneficiaries and their part in the charge "
  beneficiaries: [BeneficiaryCounterparty!]!
  " the financial entity that created the charge "
  financialEntity: FinancialEntity!
}

" defines a tag / category for charge arrangement" # eslint-disable-next-line @graphql-eslint/strict-id-in-types -- no current solution for this
type Tag {
  name: String!
}

" defines a link between a counterparty and their part in the charge "
type BeneficiaryCounterparty {
  counterparty: Counterparty!
  percentage: Percentage!
}

" represent every kind of invoice document "
union BroadInvoice = Invoice | InvoiceReceipt

" represent every kind of receipt document "
union BroadReceipt = Receipt | InvoiceReceipt

# Taxes Module

extend type Charge {
  " calculated field based on the actual ledger records, optional because not all charges has VAT "
  vat: FinancialAmount
  " withholding tax "
  withholdingTax: FinancialAmount
  " the total amount of the charge "
  totalAmount: FinancialAmount
  " linked invoice document "
  invoice: BroadInvoice
  " linked receipt document "
  receipt: BroadReceipt
  " calculated based on ledger record and transaction approvals "
  accountantApproval: AccountantApproval!
  " פחת, ציוד  "
  property: Boolean
}

extend type LedgerRecord {
  accountantApproval: AccountantApproval!
  " in shekels at the moment"
  localCurrencyAmount: FinancialAmount!
}

extend interface Transaction {
  accountantApproval: AccountantApproval!
}

" info regarding the accountant approval process "
type AccountantApproval {
  approved: Boolean!
  remark: String
}

# Hashavshevet Module

extend type LedgerRecord {
  hashavshevetId: Int
}

extend interface Transaction {
  hashavshevetId: Int
}

# Business Trip Module

extend type Charge {
  " should be later in busines trip module? "
  businessTrip: BusinessTrip
}

extend input ChargeFilter {
  " filter by business trip (should be later in busines trip module?) "
  businessTrip: ID
}

" represent a business trip "
type BusinessTrip {
  id: ID!
  name: String!
  dates: DateRange!
}

" document that haven't yet been processed"
type Unprocessed implements Document & Linkable {
  id: ID!
  image: URL
  file: URL
  charge: Charge
  documentType: DocumentType
  creditor: String
  debtor: String
  isReviewed: Boolean
}

" invoice document "
type Invoice implements Document & Linkable {
  id: ID!
  image: URL
  file: URL
  vat: FinancialAmount
  charge: Charge
  documentType: DocumentType
  creditor: String
  debtor: String
  isReviewed: Boolean

  serialNumber: String
  date: TimelessDate
  amount: FinancialAmount
}

" proforma document "
type Proforma implements Document & Linkable {
  id: ID!
  image: URL
  file: URL
  vat: FinancialAmount
  charge: Charge
  documentType: DocumentType
  creditor: String
  debtor: String
  isReviewed: Boolean

  serialNumber: String
  date: TimelessDate
  amount: FinancialAmount
}

" receipt document "
type Receipt implements Document & Linkable {
  id: ID!
  " previewable image "
  image: URL
  " gmail, pdf "
  file: URL
  charge: Charge
  documentType: DocumentType
  vat: FinancialAmount
  invoice: Invoice
  serialNumber: String
  date: TimelessDate
  amount: FinancialAmount
  creditor: String
  debtor: String
  isReviewed: Boolean
}

" Invoice receipt document - חשבונית מס קבלה "
type InvoiceReceipt implements Document & Linkable {
  id: ID!
  image: URL
  file: URL
  vat: FinancialAmount
  charge: Charge
  documentType: DocumentType
  creditor: String
  debtor: String
  isReviewed: Boolean

  serialNumber: String
  date: TimelessDate
  amount: FinancialAmount
}

" Represent a general transaction object "
interface Transaction {
  id: ID!
  " external key / identifier in the bank or card (אסמכתא) "
  referenceNumber: String!
  " eventDate "
  createdAt: Date!
  " debitDate "
  effectiveDate: TimelessDate # TODO: this should be required, but lots are missing in the DB
  " either credit or debit "
  direction: TransactionDirection!
  " the amount of the transaction "
  amount: FinancialAmount!
  " description of the transaction, as defined by the bank/card "
  description: String!
  " user custom note, saved by the bank "
  userNote: String
  " link to the account "
  account: FinancialAccount!
  " effective bank / card balance, after the transaction "
  balance: FinancialAmount!
}

" temp type until DB  supports transactions differenciation"
type CommonTransaction implements Transaction {
  id: ID!
  referenceNumber: String!
  createdAt: Date!
  effectiveDate: TimelessDate # TODO: this should be required, but lots are missing in the DB
  direction: TransactionDirection!
  amount: FinancialAmount!
  description: String!
  userNote: String
  account: FinancialAccount!
  balance: FinancialAmount!
  accountantApproval: AccountantApproval!
  hashavshevetId: Int
}

" העברה "
type WireTransaction implements Transaction {
  id: ID!
  referenceNumber: String!
  createdAt: Date!
  effectiveDate: TimelessDate!
  direction: TransactionDirection!
  amount: FinancialAmount!
  description: String!
  userNote: String
  account: FinancialAccount!
  accountantApproval: AccountantApproval!
  hashavshevetId: Int
  balance: FinancialAmount!
}

" עמלה "
type FeeTransaction implements Transaction {
  id: ID!
  referenceNumber: String!
  createdAt: Date!
  effectiveDate: TimelessDate!
  direction: TransactionDirection!
  amount: FinancialAmount!
  description: String!
  userNote: String
  account: FinancialAccount!
  accountantApproval: AccountantApproval!
  hashavshevetId: Int
  balance: FinancialAmount!
}

" המרה "
type ConversionTransaction implements Transaction {
  id: ID!
  referenceNumber: String!
  createdAt: Date!
  effectiveDate: TimelessDate!
  direction: TransactionDirection!
  amount: FinancialAmount!
  description: String!
  userNote: String
  account: FinancialAccount!
  accountantApproval: AccountantApproval!
  hashavshevetId: Int
  balance: FinancialAmount!
  from: Currency!
  to: Currency!
  " המרה של הבנק "
  bankRate: Rate!
  " בנק ישראל "
  officialRate: Rate
}

" represent atomic movement of funds "
type LedgerRecord {
  id: ID!
  creditAccount: Counterparty
  debitAccount: Counterparty
  originalAmount: FinancialAmount!
  date: TimelessDate!
  " Temporary. should be removed "
  valueDate: TimelessDate!
  " Temporary. should be removed "
  date3: TimelessDate!
  description: String!
}

extend type LedgerRecord {
  " TEMPORARY: extension to reflect original DB fields "
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_account_1: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_account_2: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  credit_amount_2: Float
  currency: Currency
  " date_3: String! "
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_account_1: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_account_2: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  debit_amount_2: Float
  details: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_credit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_credit_amount_2: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_debit_amount_1: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  foreign_debit_amount_2: Float
  # eslint-disable-next-line @graphql-eslint/naming-convention
  hashavshevet_id: Int
  # eslint-disable-next-line @graphql-eslint/naming-convention
  invoice_date: TimelessDate!
  # eslint-disable-next-line @graphql-eslint/naming-convention
  movement_type: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  reference_1: String
  # eslint-disable-next-line @graphql-eslint/naming-convention
  reference_2: String
  reviewed: Boolean
  # eslint-disable-next-line @graphql-eslint/naming-convention
  value_date: TimelessDate!
}

" represent a counterparty with a name "
type NamedCounterparty implements Counterparty {
  name: String!
}

" Represent something external that we scrape, like bank or card "
interface FinancialAccount {
  id: ID!
  charges(filter: ChargeFilter): [Charge!]!
}

" represent a single bank account"
type BankFinancialAccount implements FinancialAccount {
  id: ID!
  charges(filter: ChargeFilter): [Charge!]!
  " the external identifier of the bank account "
  accountNumber: String!
  bankNumber: String!
  branchNumber: String!
  " calculate based on bank+branch "
  routingNumber: String!
  " the external identifier of the bank account "
  iban: IBAN!
  " swift "
  swift: String!
  " country "
  country: String!
  " the name of the bank account"
  name: String
}

" represent a single credit card "
type CardFinancialAccount implements FinancialAccount {
  id: ID!
  charges(filter: ChargeFilter): [Charge!]!
  " the external identifier of the card "
  number: String!
  fourDigits: String!
}

" meta info for page pagination "
type PageInfo {
  totalPages: Int!
  currentage: Int
  pageSize: Int
}

" response for paginated charges "
type PaginatedCharges {
  nodes: [Charge!]!
  pageInfo: PageInfo!
}
