# Scalars

" Date "
scalar Date
" IBAN "
scalar IBAN
" Percentage"
scalar Percentage
" Rate "
scalar Rate
" URL "
scalar URL

# Common Types

" a date range "
type DateRange {
  start: Date!
  end: Date!
}

" represent a link to an external file "
interface Linkable {
  file: URL
}

" represent a generic document with identifier and a URL "
interface Document implements Linkable {
  id: ID!
  " previewable image "
  image: URL!
  " link to original file gmail, pdf "
  file: URL
  charge: Charge
}

" Represent financial amount "
type FinancialAmount {
  " the raw amount, for example: 19.99 "
  raw: Float!
  " formatted value with the currency symbol, like: 10$ "
  formatted: String!
  " currency of the amount "
  currency: Currency!
}

" All possible currencies "
enum Currency {
  USD
  NIS
  GBP
  EUR
}

" The other side of a transaction "
interface Counterparty {
  name: String!
}

" The direction of the transaction "
enum TransactionDirection {
  DEBIT
  CREDIT
}

# Root types

" query root "
type Query {
  financialEntity(id: ID!): FinancialEntity!
  documents: [Document!]!
}

" mutation root "
type Mutation {
  updateCharge(chargeId: ID!, fields: UpdateChargeInput!): UpdateChargeResult!
  updateTransaction(transactionId: ID!, fields: UpdateTransactionInput!): UpdateTransactionResult!
  generateTaxMovement(chargeId: ID!): GenerateTaxMovementResult!
}

" input variables for updateCharge "
input UpdateChargeInput {
  # createdAt: Date!
  # additionalDocument: [Linkable!]!
  # ledgerRecords: [LedgerRecord!]!
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # transactions: [Transaction!]!
  counterparty: CounterpartyInput
  description: String
  tag: String
  beneficiaries: String
  vat: FinancialAmountInput
  withholdingTax: FinancialAmountInput
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # invoice: Invoice
  accountantApproval: AccountantApprovalInput
  isProperty: Boolean
  # businessTrip: BusinessTrip
}

" input variables for updateTransaction "
input UpdateTransactionInput {
  referenceNumber: String
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # createdAt: Date!
  effectiveDate: Date
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # direction: TransactionDirection
  amount: FinancialAmountInput
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # description: String // NOTE: which field should be updated? and should we update fields originated at bank/card info?
  userNote: String
  # eslint-disable-next-line @graphql-eslint/no-hashtag-description -- field for the future
  # account: FinancialAccount
  balance: FinancialAmountInput
  accountantApproval: AccountantApprovalInput
  hashavshevetId: Int
}

" input variables for updateCharge.Counterparty"
input CounterpartyInput {
  name: String!
}

" input variables for updateCharge.AccountantApproval"
input AccountantApprovalInput {
  approved: Boolean!
  remark: String
}

" input variables for updateCharge.FinancialAmount"
input FinancialAmountInput {
  value: Float!
  currency: Currency!
}

" basic structure of error "
interface Error {
  message: String!
}

" common type of errors"
type CommonError implements Error {
  message: String!
}

" result type for updateCharge "
union UpdateChargeResult = Charge | CommonError

" result type for updateTransaction "
union UpdateTransactionResult = CommonTransaction | CommonError # TODO: update to match more than common transaction
" result type for generateTaxMovement "
union GenerateTaxMovementResult = Charge | CommonError # TODO: update to match more than common transaction
# Main Module

" Financial entity, identifier by ID, can be a company or individual "
type LtdFinancialEntity implements FinancialEntity {
  id: ID!
  govermentId: String!
  name: String!
  address: String!

  englishName: String
  email: String
  website: String
  phoneNumber: String

  accounts: [FinancialAccount!]!
  charges(filter: ChargeFilter): [Charge!]!
  linkedEntities: [FinancialEntity!]!
  documents: [Document]
}

" Financial entity, identifier by ID, represents an actual person "
type PersonalFinancialEntity implements FinancialEntity {
  id: ID!
  name: String!
  email: String!

  accounts: [FinancialAccount!]!
  charges(filter: ChargeFilter): [Charge!]!

  linkedEntities: [FinancialEntity!]!
  documents: [Document]
}

" represent a financial entity of any type that may hold financial accounts (company, business, individual) "
interface FinancialEntity {
  id: ID!
  accounts: [FinancialAccount!]!
  charges(filter: ChargeFilter): [Charge!]!

  linkedEntities: [FinancialEntity!]!
  documents: [Document]
}

" input variables for charge filtering "
input ChargeFilter {
  " Include only charges that doesn't have transactions linked "
  withoutTransaction: Boolean
  " Include only charges that doesn't have Ledger records linked "
  withoutLedger: Boolean
  " Include only charges that doesn't have documents linked "
  withoutDocuments: Boolean
  " Include only charges that doesn't have invoice document linked "
  withoutInvoice: Boolean
  " Include only charges occured after this date "
  fromDate: String
  " Include only charges occured before this date "
  toDate: String
}

" represrent a complex type for grouped charge with ledger info, bank/card transactions and documents "
type Charge {
  id: ID!
  " when the initial charge was created from the first event we found "
  createdAt: Date!
  " additional documents attached to the charge "
  additionalDocument: [Document!]!
  " ledger records linked to the charge "
  ledgerRecords: [LedgerRecord!]!
  " list of financial/bank transactions linked to the charge "
  transactions: [Transaction!]!
  " calculated counterparty details for the charge "
  counterparty: Counterparty
  " user description, set manually by the user "
  description: String
  " user customer tags "
  tags: [String!]!
  " a list of beneficiaries and their part in the charge "
  beneficiaries: [BeneficiaryCounterparty!]!
}

" defines a link between a counterparty and their part in the charge "
type BeneficiaryCounterparty {
  counterparty: Counterparty!
  percentage: Percentage
}

" represent every kind of invoice document "
union BroadInvoice = Invoice | InvoiceReceipt

" represent every kind of receipt document "
union BroadReceipt = Receipt | InvoiceReceipt

# Taxes Module

extend type Charge {
  " calculated field based on the actual ledger records, optional because not all charges has VAT "
  vat: FinancialAmount
  " withholding tax "
  withholdingTax: FinancialAmount
  " linked invoice document "
  invoice: BroadInvoice
  " linked receipt document "
  receipt: BroadReceipt
  " calculated based on ledger record and transaction approvals "
  accountantApproval: AccountantApproval!
  " פחת, ציוד  "
  property: Boolean
}

extend type LedgerRecord {
  accountantApproval: AccountantApproval!
  " in shekels at the moment"
  localCurrencyAmount: FinancialAmount!
}

extend interface Transaction {
  accountantApproval: AccountantApproval!
}

" info regarding the accountant approval process "
type AccountantApproval {
  approved: Boolean!
  remark: String
}

# Hashavshevet Module

extend type LedgerRecord {
  hashavshevetId: String
}

extend interface Transaction {
  hashavshevetId: String
}

# Business Trip Module

extend type Charge {
  " should be later in busines trip module? "
  businessTrip: BusinessTrip
}

extend input ChargeFilter {
  " filter by business trip (should be later in busines trip module?) "
  businessTrip: ID
}

" represent a business trip "
type BusinessTrip {
  id: ID!
  name: String!
  dates: DateRange!
}

" document that haven't yet been processed"
type Unprocessed implements Document & Linkable {
  id: ID!
  image: URL!
  file: URL
  charge: Charge
}

" invoice document "
type Invoice implements Document & Linkable {
  id: ID!
  image: URL!
  file: URL
  vat: FinancialAmount
  charge: Charge

  serialNumber: String!
  date: Date!
  amount: FinancialAmount
}

" proforma document "
type Proforma implements Document & Linkable {
  id: ID!
  image: URL!
  file: URL
  vat: FinancialAmount
  charge: Charge

  serialNumber: String!
  date: Date!
  amount: FinancialAmount
}

" receipt document "
type Receipt implements Document & Linkable {
  id: ID!
  " previewable image "
  image: URL!
  " gmail, pdf "
  file: URL
  charge: Charge
  vat: FinancialAmount
  invoice: Invoice
  serialNumber: String!
  date: Date!
  amount: FinancialAmount
}

" Invoice receipt document - חשבונית מס קבלה "
type InvoiceReceipt implements Document & Linkable {
  id: ID!
  image: URL!
  file: URL
  vat: FinancialAmount
  charge: Charge

  serialNumber: String!
  date: Date!
  amount: FinancialAmount
}

" Represent a general transaction object "
interface Transaction {
  id: ID!
  " external key / identifier in the bank or card (אסמכתא) "
  referenceNumber: String!
  " eventDate "
  createdAt: Date!
  " debitDate "
  effectiveDate: Date # TODO: this should be required, but lots are missing in the DB
  " either credit or debit "
  direction: TransactionDirection!
  " the amount of the transaction "
  amount: FinancialAmount!
  " description of the transaction, as defined by the bank/card "
  description: String!
  " user custom note, saved by the bank "
  userNote: String
  " link to the account "
  account: FinancialAccount!
  " effective bank / card balance, after the transaction "
  balance: FinancialAmount!
}

" temp type until DB  supports transactions differenciation"
type CommonTransaction implements Transaction {
  id: ID!
  referenceNumber: String!
  createdAt: Date!
  effectiveDate: Date # TODO: this should be required, but lots are missing in the DB
  direction: TransactionDirection!
  amount: FinancialAmount!
  description: String!
  userNote: String
  account: FinancialAccount!
  balance: FinancialAmount!
  accountantApproval: AccountantApproval!
  hashavshevetId: String
}

" העברה "
type WireTransaction implements Transaction {
  id: ID!
  referenceNumber: String!
  createdAt: Date!
  effectiveDate: Date!
  direction: TransactionDirection!
  amount: FinancialAmount!
  description: String!
  userNote: String
  account: FinancialAccount!
  accountantApproval: AccountantApproval!
  hashavshevetId: String
  balance: FinancialAmount!
}

" עמלה "
type FeeTransaction implements Transaction {
  id: ID!
  referenceNumber: String!
  createdAt: Date!
  effectiveDate: Date!
  direction: TransactionDirection!
  amount: FinancialAmount!
  description: String!
  userNote: String
  account: FinancialAccount!
  accountantApproval: AccountantApproval!
  hashavshevetId: String
  balance: FinancialAmount!
}

" המרה "
type ConversionTransaction implements Transaction {
  id: ID!
  referenceNumber: String!
  createdAt: Date!
  effectiveDate: Date!
  direction: TransactionDirection!
  amount: FinancialAmount!
  description: String!
  userNote: String
  account: FinancialAccount!
  accountantApproval: AccountantApproval!
  hashavshevetId: String
  balance: FinancialAmount!
  from: Currency!
  to: Currency!
  " המרה של הבנק "
  bankRate: Rate!
  " בנק ישראל "
  officialRate: Rate
}

" represent atomic movement of funds "
type LedgerRecord {
  id: ID!
  creditAccount: Counterparty
  debitAccount: Counterparty
  originalAmount: FinancialAmount!
  date: Date!
  description: String!
}

" represent a counterparty with a name "
type NamedCounterparty implements Counterparty {
  name: String!
}

" Represent something external that we scrape, like bank or card "
interface FinancialAccount {
  id: ID!
  charges(filter: ChargeFilter): [Charge!]!
}

" represent a single bank account"
type BankFinancialAccount implements FinancialAccount {
  id: ID!
  charges(filter: ChargeFilter): [Charge!]!
  " the external identifier of the bank account "
  accountNumber: String!
  bankNumber: String!
  branchNumber: String!
  " calculate based on bank+branch "
  routingNumber: String!
  " the external identifier of the bank account "
  iban: IBAN!
  " swift "
  swift: String!
  " country "
  country: String!
  " the name of the bank account"
  name: String
}

" represent a single credit card "
type CardFinancialAccount implements FinancialAccount {
  id: ID!
  charges(filter: ChargeFilter): [Charge!]!
  " the external identifier of the card "
  number: String!
  fourDigits: String!
}
